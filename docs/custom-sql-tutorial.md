# Using Custom SQL

So what is this "weird custom SQL" mentioned in the README?

Here's a use case:

You have custom post type for events and you have the event start time
(timestamp) as a meta field and you want to display the events in this order:

1. First display the events that start today or have started today
2. Then display the events that are the closest to starting
3. Do not show past events at all

The tricky bit is the handling of the events that have been already started
today because they they match to both 1 and 3. In pure MySQL terms this can
be implemented with a clever use of `CASE`, `FROM_UNIXTIME` `DATE` and
`NOW()`.

This tutorial is very advanced level. If you get through it and understand
everything I bet you can safely call yourself a "senior wp-graphql
developer". I assume you known basics of WP development, WP-CLI, SQL and
WPGraphQL.

For purposes of this tutorial we simplify the example a bit so we don't have
to deal with changing time.

Lets create some testing data.

Run this with `wp eval-file create-data.php`

```php
foreach (range('A', 'Z') as $num => $char) {
    $num++; // start from 1
    $post_id = wp_insert_post([
        'post_title' => "$char post $num",
        'post_type' => 'post',
        'post_status' => 'publish'
    ]);

    if ($num % 2 === 0) {
        update_post_meta($post_id, 'example', 'Even ' . $char);
    } else {
        update_post_meta($post_id, 'example', 'Odd ' . $char);
    }

    echo "Created $post_id\n";
}
```

This will create a post for each character in the alphabet and saves whether
it's in a even or odd position in the alphabet to `example` meta.

We will be creating a custom graphql input field that prioritizes ordering
based on the `example` meta.

But first we'll want to expose the `example` meta to the GraphQL schema for
debugging purposes.

```php
add_action(
    'graphql_register_types',
    function () {
        register_graphql_field('Post', 'example', [
            'type' => 'String',
            'resolve' => function (\WPGraphQL\Model\Post $post) {
                return get_post_meta($post->ID, 'example', true);
            }
        ]);
    },
    10,
    0
);
```

We should be now able to query the posts with

```graphql
{
    posts(where: { orderby: { field: TITLE, order: ASC } }) {
        nodes {
            title
            example
        }
    }
}
```

We'll get the posts in the alphabetical order as we asked

```json
{ "title": "A post 1", "example": "Odd A" },
{ "title": "B post 2", "example": "Even B" },
{ "title": "C post 3", "example": "Odd C" },
{ "title": "D post 4", "example": "Even D" },
...
```

Next we'll need to add the input field which can be used to prioritize the
posts. WPGraphQL allows PHP developers to extend the `where` input field. So
in the `graphql_register_types` action we can extend the
`RootQueryToPostConnectionWhereArgs` type. You can find out this type name by
looking it up from [wp-graphiql][].

[wp-graphiql]: https://github.com/wp-graphql/wp-graphiql

```php
add_action(
    'graphql_register_types',
    function () {
        register_graphql_field(
            'RootQueryToPostConnectionWhereArgs',
            'prioritize',
            [
                'type' => 'String'
            ]
        );
    },
    10,
    0
);
```

It's now legal to write

```graphql
{
    posts(where: { prioritize: "Odd" }) {
        nodes {
            title
            example
        }
    }
}
```

But we must use it for it have any effect. We will use the
`graphql_map_input_fields_to_wp_query` filter to map it into to the query
args of the `\WP_Query` instance WPGraphQL is internally using.

```php
add_filter(
    'graphql_map_input_fields_to_wp_query',
    function (array $query_args, array $where_args) {
        if (!isset($where_args['prioritize'])) {
            // If the "prioritize where is argument is not used, bail out.
            // We might also want to check for the specific post type / connection resolver type too
            // to be sure we don't mess with queries we don't intend to
            // Here are the filter arguments https://github.com/wp-graphql/wp-graphql/blob/59b1fef494b878de8d9912b4c8fcd054d548da47/src/Data/Connection/PostObjectConnectionResolver.php#L392-L409
            return $query_args;
        }

        // The $query_args is passed to the \WP_Query instance so just copy the
        // value from graphql where args
        $query_args['prioritize'] = $where_args['prioritize'];

        return $query_args;
    },
    10,
    2
);
```

This does have any effect yet neighter but it exposes the argument to the
`\WP_Query` filters. So let's modify the SQL query generated by the
`\WP_Query` instance using it

```php
add_filter(
    'posts_clauses',
    function (array $fields, \WP_Query $query) {
        global $wpdb;

        if (!isset($query->query_vars['prioritize'])) {
            // Bail out if not using the 'prioritize' query var passed from the
            // WPGraphQL filter. NOTE: You should probably use more unique query
            // var name since this hook is called on every \WP_Query usage in
            // WP.
            return $fields;
        }

        $meta_key = 'example';
        $prioritize = esc_sql($query->query_vars['prioritize']);

        // Create join for the meta field. We use a custom alias for the join so
        // we can reference it from the "fields" clause
        $join_name = 'CUSTOM_META_JOIN';
        $join = " LEFT JOIN $wpdb->postmeta AS $join_name
            ON $wpdb->posts.ID = $join_name.post_id
            AND $join_name.meta_key = '$meta_key' ";

        // Append it to the existing joins
        $fields['join'] .= $join;

        // Let's add a custom field with alias to the query which can be
        // referenced in ordering.
        $field_name = 'PRIORITIZE_ORDER';
        $field = " CASE
            WHEN $join_name.meta_key = '$meta_key'
            AND $join_name.meta_value LIKE '${prioritize}%'
                THEN 1
                ELSE 2
            END AS $field_name";

        // Append it to the fields
        $fields['fields'] .= ", $field";

        // Make this field the first ordering directive by prepending it
        $fields['orderby'] = "${field_name}, " . $fields['orderby'];

        return $fields;
    },
    10,
    2
);
```

Whoa! That's a lot! But if you got this far you can congratulate youself! You can now write:

```graphql
{
    posts(
        where: { prioritize: "Even", orderby: { field: TITLE, order: ASC } }
    ) {
        nodes {
            title
            example
        }
    }
}
```

and you'll get the "Even" posts first in alphabetical order (BDFHJ...)

```json
{ "title": "B post 2", "example": "Even B" },
{ "title": "D post 4", "example": "Even D" },
{ "title": "F post 6", "example": "Even F" },
...
```

With `wp-graphql-offset-pagination` you can paginate to the "Odd" posts

```graphql
{
    posts(
        where: {
            prioritize: "Even"
            orderby: { field: TITLE, order: ASC }
            offsetPagination: { size: 10, offset: 12 }
        }
    ) {
        nodes {
            title
            example
        }
    }
}
```

and you'll get

```json
{ "title": "Z post 26", "example": "Even Z" },
{ "title": "A post 1", "example": "Odd A" },
{ "title": "C post 3", "example": "Odd C" },
...
```

But let's go back to the SQL we just created. Specifically the `CASE` statement:

```sql
CASE
WHEN $join_name.meta_key = '$meta_key' AND $join_name.meta_value LIKE '${prioritize}%'
    THEN 1
    ELSE 2
END
```

This is the magic that allows us to modify the ordering in SQL almost
arbitrarily. With the CASE statement we can turn any SQL expression to a
number which can be used in the ORDER statement.

If you still remember the use case I mentioned in the begining, this method
can be used to detect the "current day" and prioritize that.

The WHEN statment for it would be something like this

```sql
WHEN
    DATE( FROM_UNIXTIME( $join_name.meta_value ) ) = DATE( NOW() )
    AND $join_name.meta_key = '$meta_key'
```

Finally you might want to try you what happens you paginate with the core
wp-graphql cursors. The first page looks good, maybe the second too but at
some point it goes of the rails and misses some data.

If you are interested why cursor pagination is a good idea despite of its limitiations
I's recommend you to read this article from Slack Engineering

<https://slack.engineering/evolving-api-pagination-at-slack-1c1f644f8e12>

tl;dr it's faster on big data sets.
